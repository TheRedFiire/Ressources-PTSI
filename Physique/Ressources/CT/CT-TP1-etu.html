import numpy as np
import matplotlib.pyplot as plt
import numpy.random as rd

################################################################
#
#   CONSIGNES
#
#   Modifier et/ou compléter toutes les lignes qui commencent par un "##"
#
#################################################################

# Il y a quatre grandeurs d'entrée : les quatre positions utiles pour déterminer les deux longueurs
##x_L_1 =  # en cm
##x_L_2 =  # en cm
L = x_L_2 - x_L_1 # valeur mesurée de L en cm

##x_l_1 =  # en cm
##x_l_2 =  # en cm
l = x_l_2 - x_l_1 # valeur mesurée de l en cm

# on modélise la variabilité des quatre grandeurs d'entrée en donnant
# - étendue = largeur de l'intervalle où se trouvent les valeurs raisonnablement attribuables à la grandeur
# - modèle de distribution de ces valeurs (rectangulaire, triangulaire, gaussien)
# il n'y a pas de « mauvaises réponses », il y a juste des choix raisonnables à effectuer
# et il faut être capable de les argumenter
##u_x_L2 =  # en cm 
##u_x_L1 =  # en cm 
##u_x_l2 =  # en cm  
##u_x_l1 =  # en cm 

# L = x_L_2 - x_L_1 et l = x_l_2 - x_l_1 sont des combinaisons linéaires 
# on utilise la relation de propagation des incertitudes du cours
##u_L = 
##u_l = 

# On détermine la valeur mesurée de A
A = L*l

# A = L*l est un produit 
# on utilise la relation de propagation des incertitudes du cours
##u_A = 
print('A =', A,'cm² ;','u_A =', u_A, 'cm²')

# on détermine C_L et C_l comme expliqué en Annexe
# Pour cela on écrit l'expression de u_A**2 :
# u_A**2 = A**2/L**2 * u_L**2 + A**2/l**2 * u_l**2
# et on l'identifie à 
# u_A**2 = C_L**2 * u_L**2 + C_l**2 * u_l**2
# on trouve
##C_L = 
##C_l = 
# finalement les contributions à la variance sont
##C_V_L = 
##C_V_l = 

print("C_V_L = ",100*C_V_L,"%","C_V_l =",100*C_V_l,"%")

# nombre de tirages
n = 100000

# on utilise la bibliothèque numpy.random qu'on appelée rd pour faire des tirages aléatoires
# on réutilise les modèles de variabilité décrits au début du TP

# syntaxe pour la distribution triangulaire : 
# rd.triangular(borne inférieure, centre de l'intervalle, borne supérieure, nombre de tirages)
                                                         # syntaxe alternative

# syntaxe pour la distribution rectangulaire : 
# rd.uniform(borne inférieure, borne supérieure, nombre de tirages)


##x_L_1_MC =  # n tirages de x_L_1 
##x_L_2_MC =  # n tirages de x_L_2 
L_MC = x_L_2_MC-x_L_1_MC # n valeurs de L

# idem pour l
##x_l_1_MC = 
##x_l_2_MC = 
l_MC = x_l_2_MC-x_l_1_MC

A_MC = L_MC*l_MC # n valeurs de A

plt.figure()
plt.hist(x_l_1_MC,bins='rice')
plt.ylabel('effectifs')
plt.xlabel('$x_{l1}$ (cm)')
plt.title("Distribution des valeurs de $x_{l1}$.\n Méthode de Monte Carlo, modèle triangulaire, 0,5 mm d'étendue.")
plt.show()

plt.figure()
plt.hist(x_l_2_MC,bins='rice')
plt.ylabel('effectifs')
plt.xlabel('$x_{l2}$ (cm)')
plt.title("Distribution des valeurs de $x_{l2}$.\n Méthode de Monte Carlo, modèle rectangulaire, 1 mm d'étendue.")
plt.show()

plt.figure()
plt.hist(l_MC,bins='rice')
plt.ylabel('effectifs')
plt.xlabel('$\ell$ (cm)')
plt.title('Distributions des valeurs de $\ell$')
plt.show()

# Pour ne pas surcharger l'affichage on ne représente que les histogrammes liées à l.
# ceux liés à L sont tout à faits similaires.

#plt.figure()
#plt.hist(x_L_1_MC,bins='rice')
#plt.ylabel('effectifs')
#plt.xlabel('$x_{L1}$ (cm)')
#plt.title('x_{L1}')
#plt.show()

#plt.figure()
#plt.hist(x_L_2_MC,bins='rice')
#plt.ylabel('effectifs')
#plt.xlabel('$x_{L2}$ (cm)')
#plt.title('x_{L2}')
#plt.show()

#plt.figure()
#plt.hist(L_MC,bins='rice')
#plt.ylabel('effectifs')
#plt.xlabel('$L$ (cm)')
#plt.title('Distributions des valeurs de $L$.')
#plt.show()


plt.figure()
plt.hist(A_MC,bins='rice')
plt.ylabel('effectifs')
plt.xlabel('$A$ $(\mathrm{cm}^2)$')
plt.title('Distributions des valeurs de $A$')
plt.show()

##A_moy =  # valeur moyenne = meilleur estimateur de A
##u_A_MC =  # écart-type échantillonnal = incertitude-type sur une valeur de A
print('A_moy =',A_moy,'cm²','u_A =', u_A_MC,'cm²')

# test de compatibilité entre la valeur mesurée déterminée 
# grâce aux formules de propagation des incertitudes et la valeur
# simulée par la méthode de Monte Carlo avec le même modèle
##z_score = 
print('z_score =',z_score)
if z_score < 2:
    print('Les deux résultats sont compatibles car leur z_score est inférieur à 2.')
else:
    print("Les deux résultats ne sont pas compatibles car leur z_score n'est pas inférieur à 2.")


