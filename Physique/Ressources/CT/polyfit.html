## Importation des bibliothèques utiles
import numpy as np                    # pour le traitement vectoriel des données
import matplotlib.pyplot as plt       # pour les graphiques

## Saisie des données expérimentales
v_mesure = np.array([10.3,21.08,28.92,39.7])     # en m/s
t_mesure = np.array([0.99,2.06,3.05,3.98])       # en s

## modélisation par la relation v=p*t+b
## c'est un polynôme d'ordre 1
## polyfit() va chercher à estimer les valeurs des parametres[0] et parametres[1]
## telles que v = parametres[0]*t+parametres[1]
parametres = np.polyfit(t_mesure, v_mesure, 1)  # calcul des paramètres d'ajustement (parametres est la liste des coefficients polynomiaux)

## Si on veut on peut nommer ces paramètres
p = parametres[0] # pente
b = parametres[1] # ordonnée à l'origine      

## On peut directement calculer les valeurs de v prévues par le modèle paramétré
## grâce à la fonction polyval() qui effectue directement le calcul des valeurs :
## v = parametres[0]*t+parametres[1]
v_modele = np.polyval(parametres,t_mesure)                 # valeurs prévues par le modèle
#valeurs_modele = parametres[0]*t_mesure+parametres[1]     # valeurs prévues par le modèle
#valeurs_modele = p*t_mesure+b                             # valeurs prévues par le modèle

plt.figure()                                 # création d'une figure
plt.plot(t_mesure, v_mesure, 'oc', label = 'Points expérimentaux')   # représentation des points expérimentaux
plt.plot(t_mesure, v_modele, '--b', label = 'Modèle $v=p*t+b$')      # représentation des préviions du modèle
plt.xlabel("$t$ (s)")                         # axe des abscisses
plt.ylabel("$v$ (m/s)")                       # axe des ordonnées
plt.grid(), plt.legend(loc = 0)               # quadrillage en arrière-plan et légende
plt.title("Étude d'une relation vitesse-temps")
plt.savefig("../Images/courbes-vitesse-temps",dpi=300)
plt.show()
